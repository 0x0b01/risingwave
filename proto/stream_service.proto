syntax = "proto3";

import "stream_plan.proto";
import "common.proto";
import "task_service.proto";

package risingwave.streaming.proto;
option java_package = "com.risingwave.proto.streaming.streamnode";
option java_multiple_files = true;
option optimize_for = SPEED;

// Assuming only one compute node for streaming now.
message CreateActorRequest {
  uint32 request_id = 1;
  risingwave.streaming.proto.StreamFragment fragment = 2;
}

message CreateActorResponse {
  risingwave.proto.common.Status status = 1;
}

message DropActorRequest{
  uint32 request_id = 1;
  repeated uint32 fragment_id = 2;
}

message DropActorResponse{
  risingwave.proto.common.Status status = 1;
}

// Encode which host machine a actor resides.
message ActorInfo {
  uint32 fragment_id = 1;
  risingwave.executor.proto.HostAddress host = 2;
}

message ActorInfoTable{
  repeated ActorInfo info = 1;
}

// Before starting streaming, the leader node broadcast the actor-host table to needed workers.
message BroadcastActorInfoTableResponse{
  risingwave.proto.common.Status status = 1;
}

service StreamService {
  rpc CreateActor(CreateActorRequest) returns (CreateActorResponse);
  rpc DropActor(DropActorRequest) returns (DropActorResponse);
  rpc BroadcastActorInfoTable(ActorInfoTable) returns (BroadcastActorInfoTableResponse);
}

// TODO: Lifecylce management for actors.
