syntax = "proto3";


import "google/protobuf/any.proto";
import "data.proto";
import "expr.proto";


package risingwave.executor.proto;
option java_package = "com.risingwave.proto.plan";
option java_multiple_files = true;
option optimize_for = SPEED;

message DatabaseRefId {
    int32 database_id = 1;
}

message SchemaRefId {
    DatabaseRefId database_ref_id = 1;
    int32 schema_id = 2;
}

message TableRefId {
    SchemaRefId schema_ref_id = 1;
    int32 table_id = 2;
}

message ColumnDesc {
    enum ColumnEncodingType {
        INVALID = 0;
        RAW = 1;
        LZO = 2;
        LZ4 = 3;
        ZSTD = 4;
        RUN_LENGTH = 5;
        BYTE_DICT = 6;
        DELTA = 7;
    }
    risingwave.executor.proto.DataType column_type = 1;
    ColumnEncodingType encoding = 2;
    bool is_primary = 3;
}

message SeqScanNode {
    TableRefId table_ref_id = 1;
    repeated int32 column_ids = 2;
}

message ProjectNode {
    repeated risingwave.expr.proto.ExprNode select_list = 1;
}

message FilterScanNode {
    TableRefId table_ref_id = 1;
    repeated int32 column_ids = 2;
}

message InsertValueNode {
    // Not intended to be a general wrapper of repeated exprs.
    // Only used when nested in another `repeated`.
    message ExprTuple {
        repeated risingwave.expr.proto.ExprNode cells = 1;
    }
    TableRefId table_ref_id = 1;
    repeated int32 column_ids = 2;
    repeated ExprTuple insert_tuples = 3;
}

message CreateTableNode {
    TableRefId table_ref_id = 1;
    repeated ColumnDesc column_descs = 2;
    // Other fields not included yet:
    // primarykey_col_ids, dist_type, distkey_col_id, append_only
}

message HashAggNode {
    repeated risingwave.expr.proto.ExprNode group_by_keys = 1;
    repeated risingwave.expr.proto.ExprNode aggregations = 2;
}


message PlanNode {
    enum PlanNodeType {
        INVALID = 0;
        FILTER_SCAN = 1;
        INSERT_VALUE = 2;
        SEQ_SCAN = 3;
        PROJECT = 4;
        CREATE_TABLE = 5;
        HASH_AGG = 6;
    }
    PlanNodeType node_type = 1;
    google.protobuf.Any body = 2;
    repeated PlanNode children = 3;
}

message ShuffleInfo {
    enum PartitionMode {
        // No partitioning at all, used for root segment which aggregates query results
        SINGLE = 0;
        BROADCAST = 1;
        HASH = 2;
    }

    message BroadcastInfo {
        uint32 count = 1;
    }

    message HashInfo {
        enum HashMethod {
            CRC32 = 0;
        }
        uint32 output_count = 1;
        HashMethod hash_method = 2;
        repeated uint32 keys = 3;
    }

    PartitionMode partition_mode = 1;

    oneof shuffle_info {
        BroadcastInfo broadcast_info = 2;
        HashInfo hash_info = 3;
    }

    // TODO: Add fields to optimize for local buffer
}

message PlanFragment {
    PlanNode root = 1;
    ShuffleInfo shuffle_info = 2;
}
